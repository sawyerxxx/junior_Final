####第一章
**计算机图形学:**是研究怎样利用计算机来显示、生成和处理图像原理、方法的一门学科。

P.S.研究的对象是图形

图形学的基本要素：

1. 刻画形状的点、线、面等几何要素。
2. 反应物体本身固有属性，如表面属性或者材质的明暗、灰度、色彩等非几何要素

表示带有色彩及形状信息的图和形常用的两种方法：**点阵法**和**参数法**。

把**参数法**描述的图形叫做**图形**。
把**点阵法**描述的图形叫做**图像**。

图像是指计算机内以位图形式存在的灰度信息,而图形则含有几何属性,或者说更强调场景的几 何表示,是由场景的几何模型和景物的物理属性共同组成的。

####第二章

计算机图形系统的功能：

1. 计算功能
2. 存储功能
3. 交互功能
4. 输入功能
5. 输出功能

计算机图形系统的结构
图1

图形软件主要分为：**图形应用数据结构**、**图形应用软件**和**图形支撑软件**。

图形输入设备：键盘、鼠标器、光笔、触摸屏、操纵杆、跟踪球和空间球、数据手套、数字化仪、图像扫描仪、声频输入系统、视频输入系统。

图形显示设备：

1. 阴极射线管
	- 电子枪：产生一个沿着管轴（z轴）方向前进的细电子束，用于轰击荧光屏。要求：
		- 具有足够的电流强度
		- 电流大小和有无必须是可控的
		- 具有很高的速度
		- 在荧光屏上应能聚焦很小的光亮，以保证显示器有足够的分辨率
	- 偏转系统：
		- 磁偏转：保证CRT图形的清晰度
		- 电偏转：朝带正高电压的极板偏转
	- CRT的荧光屏：用荧光粉涂敷在玻璃底壁上制成的。
	- 彩色阴极射线管:荧光粉由RGB3种，射线也有RGB3种

2. CRT图形显示器：
	- 随机扫描显示器：只在需要的地方扫描，不必全屏扫描。又称为向量显示器，笔画显示器。
	- 直视存储管图形显示器：存在收集栅和存储栅：由于暂存，这样可以长时间显示一副图片，不过如果要重新显示新的图片就需要一段时间
	- 光栅扫描图形显示器：最广泛的CRT图形显示器
		- 回扫的模式：
			- 水平回扫
			- 垂直回扫
		- 扫描方法：
			- 隔行扫描，从左到右，结束后返回最开始的地方。隔行扫描可以在一般的时间内，可以观察到整个屏幕的显示
			- 逐行扫描

分辨率：像素点是光点的集合，光点是电子书在显示器上能够显示的最小发光点。像素点是图形显示分辨率所能提供的最小像素点。

- 屏幕分辨率：最大可能的分辨率
- 显示分辨率：显示模式一般用水平方向乘垂直方向上显示的字符总数的乘积。
- 存储分辨率：帧缓冲存储区的大小：** 计算方法：x方向上的像素点数 * y方向上的存储点数 * (log2 2^n )/ 8** 2^n为色彩，如黑白为2^1,256色为2^8

####第四章：
基本图形元素：

- 点：点事0维几何元素，是形体的基本元素，一维中为一元组，二维中为二元组，三位中为三元组。
- 线：线是一维几何元素，曲线由一系列型值点或控制点表示
- 面：是二维几何元素，可以无内环，但是必须有外环，其外法线适量方向作为该面的正向。
- 环：最大边界的环成为外环，外环逆时针方向排序，内环为顺时针方向排序。
- 体：三维几何元素。

几何信息与拓扑信息：

- 点：（x,y,z）
- 直线：x = (y - y0)/a = (z - z0)/b
- 平面：ax+by+cz+b = 0

拓扑信息：因为形体的表示出了需要集合信息以外，还应该提供分量之间的互相联系的关系，即**拓扑信息**

坐标系：

- 建模坐标系：定义基本形体或图素。可看做局部坐标系
- 用户坐标系：定义用户的整图结构或最高层图像结构，根据情况选择不同坐标系。一般称为全局坐标系（相对建模坐标系而言）
- 观察坐标系：指定裁剪控件，定义观察平面，把三位形体的用户坐标变换成规格化的设备坐标。
- 规格化的设备坐标，用来定义视图区，一般为（0,0,0）到（1,1,1）之间
- 设备坐标系(DC)，是图形输入/输出设备的坐标系。

**欧拉公式：V(简单多面体的顶点数)-E(边数)+F(面数目)=2**

**拓展后的欧拉公式：V-E+F-H(孔的个数)=2(C(独立不想连接的多面体数目))-G(贯穿的多面体孔的个数))**

三位形体表示缺陷：

1. 有二义性
2. 不存在面的信息
3. 不能表示出曲面的轮廓线

实体模型表示一般分为3类：

1. 边界表示，用一组曲面来表示
2. 构造实体几何表示，立方体、长方体、圆柱体、圆锥体等的基本体素的交并差等运算。
3. 控件分割表示，划分成为一组小的菲重叠的连续实体

多边形表面模型：

- 数据结构：
	- 根据点线，线面的关系退出Ax+By+Cz+D = 0中的ABC，从而更加方便的推算出一点点是否在空间内。
	- 拓扑信息：翼边结构
	- 属性信息
- 多边形网络
- 八叉树（用F(全覆盖)B(部分覆盖)E(完全没有覆盖)来表示），把B不断细分，知道不出现B为止


####第五章
直线扫描转换要求：

1. 直线要直
2. 直线端点要准确
3. 直线的亮度、颜色要均匀
4. 划线的速度要尽可能快

**数值微分算法：不利于硬件实现**

思路：每一个点基于所在直线的极限值

1. 首先比较dx和dy之间哪个哪个更大，更大的说明往那个方向为基准，另一份方向上+0或者+1
2. 其次epls为dx，dy中最大的那个值
3. dx，dy分别处以epls从而获得递进量
4. 画点的时候，较小的那个值在原值（即极限直线上的值+0.5）
5. x和y分别增加对应的递进量
6. 重复4，5步，直到直线画完


```
void DDALine(int x0,int y0,int x1,int y1,int color){	int x;	float dx,dy,y,k;	dx=x1-x0;	dy=y1-y0;	k=dy/dx;	y=y0;	for(x=x0;x<=x1;x++){	drawpixel(x,int(y+0.5),color);	y=y+k;	}}
```
**中点Bresenham算法**

思路：每一个点基于上一个点的d的值

1. 输入两个端点
2. 计算初始值dx，dy，d=dx-2dy,x=x0,y=y0
3. 判断d的值，如果d<0,那么(x,y)为(x+1,y+1),d = d+2dx-2dy,否则(x,y)为(x+1,y),d = d-2dy
4. 重复3，直到直线结束

```
void MidBresenhamLine(int x0,int y0,int x1,int y1,int color)
{
	int dx,dy,d,UpIncre,DownIncre,x,y;
	//更换x，y起始点位置
	if(x0 > x1){
		x = x1;x1 = x0;x0 = x;
		y = y1;y1 = y0;y0 = y;
	}
	x = x0;y = y0;
	dx = x1-x0;dy = y1 - y0;
	d = dx - 2*dy;
	UpIncre = 2 * dx - 2 * dy; DownIncre = -2 * dy
	while(x <= x1){
		putpixel(x,y,color);
		x++;
		if(d<0){
			y++;
			d+=UpIncre;
		}else{
			d += DownIncre
		}
	}

}

```
**改进Bresenham算法**

思路：制作虚拟网格线，结合上面两个方面在每一步的时候都是根据上一步进行计算，不过d的值每次增加k，如果d大于1，则d-1，否则不变。

```
void  BresenhamLine(int x0,int y0,int x1,int y1,int color){
	int x,y,dx,dy,e;
	dx = x1 - x0;
	dy = y1 - y0;
	e = -dx;x = x0;y = y0;
	while(x < x1){
		putpixel(x,y,color);
		x++;
		e=e+2*dy;
		if(e>0){
			y++;
			e=e-2*dx
		}
	}	
}

```

八分法画圆，通过计算一个区域的x,y，然后通过绘制(x,y),(-x,y),(x,-y),(-x,-y),(y,x),(-y,x),(y,-x),(-y,-x)

**多边形扫描算法：**

- x-扫描线算法：按照线扫描线的顺序，计算扫描线与多边形的相交区间，在用要求的颜色显示这些区间的像素，即完成填充工作。区间的端点可以通过计算扫描线与多边形边界线的焦点获得。
	- 取整：当该交点处于区间的左边界上的时候，x坐标向右取整，当该交点处于区间的右边界上的时候，x坐标向左取整。
	- 步骤：
		1. 求交点
		2. 排序
		3. 焦点配对，找到对应的相交区间
		4. 区间填色。
- 改进的有效边表算法
	- 有效边表的节点：|x|ymax|1/k|next|
	- 为了有效边表的构造，需要构造一个边表，来存放多边形除水平边外的所有边的信息
	- 桶：边表上纵向列表上的每个节点
	- 通过分离某些变缩短以分离那些应计为一个交点的顶点。
	- 算法的步骤：
		1. 初始化，构造边表，AET表置空
		2. 降低一个ET表的边与AET表合并
		3. 由AET表中取出焦点并进行填充，填充的时候设置一个布尔值（初值为假），令指针从有效边表中第一个节点（交点）到最后一个节点遍历一次。每访问一个节点，把b取反一次，若b为真，则把从前节点的x值开始到下一节点的x值结束的区间用多边形色填充，填充后删除y=ymax的边。
		4. yi+1 = yi + 1，根据x+1 = xi +1/k计算修改AET表，同时合并ET表中y = yi+1桶中的边，按次序插入到AET表中，形成新的AET表
		5. AET表不为空转到3，否则结束
- 区域填充
	- 概念： 
		- 种子点：从区域中的一点（用户指定的一点）开始，由该点向外扩展
		- 4-邻接点：一个点与其上、下、左、右4个相邻的店
		- 8-邻接点：一个点与其上、下、左、右、左上、右上、左下、右下8个相邻的店
		- 4-连通区域：访问区域内已知点的4-邻接点来遍历整个区域
		- 8-连通区域：访问区域内已知点的8-邻接点来遍历整个区域，8连通区域的边界一定是4-连通的。
	- 填充算法
		- 边界填充算法：为了解决直接使用4-连通边界填充算法导致效率低下和要求大量的储存空间
			- 种子像素入栈
			- 栈顶像素出栈，填充像素所在扫描行，直到遇到边界像素为止。并记录下扫描区间的x坐标范围[x1,x2],然后检查上下两条扫描线上位于[x1,x2]坐标区间内的未被填充的连续水平像素段，将每个连续像素段的最左像素取做种子像素压入堆栈。
			- 检查栈是否为空，若非空，则重复进行步骤2，直到栈为空。
		
	
	
